---
title: "The module module"
subtitle: Level Up with Shiny for R
author: <code>posit::conf(2024)</code>
date: 2024-08-12

format:
  utopia-slides-revealjs:
    html-math-method: plain
    revealjs-url: slides/assets/reveal.js-4.5.0
    slide-level: 2
    # chalkboard: true
    theme:
      - slides.scss
      - assets/code-blocked.scss
    css:
      - ../auto-dark-mode.css

revealjs-plugins:
  - utopia-slides

knitr:
  opts_chunk: 
    collapse: true
    comment: "#>"

filters:
  - webr

webr:
  show-startup-message: false
  packages:
    - dplyr
    - collegeScorecard

editor:
  render-on-save: true
---

# You might not need a module {.middle .text-center}

## {.middle}

::: {.flex}
::: w-50
[Why use **Shiny modules**?]{.fs-step-2 .font-heading .b}

::: {.fragment}
* Avoid repeating logic \
  &nbsp;

* Make your code more reusable \
  &nbsp;
:::
:::
:::

## {.middle}

::: {.flex}
::: w-50
[Why use [functions]{.b .orange}?]{.fs-step-2 .font-heading .b}

* Avoid repeating logic \
  &nbsp;

* Make your code more reusable \
  &nbsp;
:::

::: {.w-50 .fragment}
[Why use [Shiny modules]{.b .blue}?]{.fs-step-2 .font-heading .b}

::: {.incremental}
* Avoid repeating \
  **Shiny UI/Server logic**

* Make your code more reusable \
  **to Shiny app developers**
:::
:::
:::

## Maybe you could use a function? {.text-center .middle .bg-gradient-yellow-peach style="--slide-heading-color: white"}

```{=html}
<style>
.bg-gradient-yellow-peach {
  background: hsla(29, 92%, 55%, 1);
  background: linear-gradient(315deg, hsla(29, 92%, 55%, 1) 0%, hsla(0, 87%, 62%, 1) 57%);
  background: -moz-linear-gradient(315deg, hsla(29, 92%, 55%, 1) 0%, hsla(0, 87%, 62%, 1) 57%);
  background: -webkit-linear-gradient(315deg, hsla(29, 92%, 55%, 1) 0%, hsla(0, 87%, 62%, 1) 57%);
}
</style>
```

## {auto-animate=true}

```{r}
library(dplyr)
library(collegeScorecard)
```

```{r}
#| echo: true
school |>
  filter(
    state == "CA",
    control == "Public",
  ) |>
  count() |>
  pull(n)
```

## {auto-animate=true}

```{r}
#| echo: true
school |>
  filter(state == "CA") |>
  filter(control == "Public") |>
  count() |>
  pull(n)
```

## {auto-animate=true}

```{r}
#| echo: true
#| code-line-numbers: true
school |>
  filter(state == "CA") |>
  filter(control == "Public") |>
  count() |>
  pull(n)

school |>
  filter(state == "CA") |>
  filter(control == "Nonprofit") |>
  count() |>
  pull(n)
```

## {auto-animate=true}

```{r}
#| echo: true
#| code-line-numbers: "|1,2,4,5,8,9,11,12,15,16,18,19|3,10,17|1-2|3-5"
school |>
  filter(state == "CA") |>
  filter(control == "Public") |>
  count() |>
  pull(n)

school |>
  filter(state == "CA") |>
  filter(control == "Nonprofit") |>
  count() |>
  pull(n)

school |>
  filter(state == "CA") |>
  filter(control == "For-profit") |>
  count() |>
  pull(n)
```

## 

::: {.fs-step-1}
```{webr-r}
school |>
  filter(state == "CA") |>
  filter(control == "Public") |>
  count() |>
  pull(n)
```
:::

::: notes
```{.r}
school_count_control <- function(school, control) {
  school |>
    filter(control == !!control) |>
    count() |>
    pull(n)
}
```

Note, `{{ control }}` or `!!control` work here.
When to embrace and when to double bang?
Try one, if it doesn't work, try the other.
:::

## Your Turn `_exercises/07_app.R` {#your-turn-1 .slide-your-turn}

{{< countdown 6:00 bottom="2rem" right="2rem" >}}

::: w-90
1. **Refactor the code for the two plots into a single function.**
   You can put this function in this app file in the server section around the
   `## Put your function here ##` line.

2. **Replace the the duplicated code** with your new function.

3. ðŸ¤” What logic is encapsulated in your function? \
   How could your function be used outside of this app? \
   How well will your function compose with other functions?
:::

## UI functions

Same idea, but for UI functions.

Examples:

* A `card_dark()` with a title and custom class.

* A `sidebar_right()`

* Some other Bootstrap component
    * `<span class="badge text-bg-secondary">New</span>`
    * [Badges Â· Bootstrap v5.3](https://getbootstrap.com/docs/5.3/components/badge/)


## Your turn

TK: `_exercises/08_app.R`

Make a `card_dark()`


## Where to put those functions?

`loadSupport()`

# Modules {.middle}

## Let's make a map card

* Put a `leafletOutput()` in the card
* Find out we're repeating a bunch of to avoid ID conflicts
* This is why you need a module
* Work through turning `card_dark()` into `card_map()`

## Your turn

TK: `_exercises/09_app.R`

Modules for value box, example from https://github.com/gadenbuie/slides/blob/gh-pages/bslib-modern-dashboards/jeep-weather/app-bslib.R
Except, part of an app that compares two schools.

Goal is a module that looks like this:

```{.r}
ui_forecast_value_box <- function(id) {
  ns <- NS(id)

  value_box(
    title = textOutput(ns("wday")),
    value = uiOutput(ns("weather")),
    showcase = uiOutput(ns("icon")),
    showcase_layout = "top right",
    theme = "bg-gradient-blue-purple"
  )
}
```

# Modules Plus {.middle}

## Modules can call other modules

If you're in a module, just forget for a second, pretend like you aren't and call the other module

## Your turn

TK: `_exercises/10_app.R`

Turn each comparison column into a full module:

* college selector
* value box
* bar plot
* map card

## Communicating with your module

Suppose you put this module into your app and realize that actually, you'd like to

a. Know which college is selected
b. Set the college, e.g. pick a random school

## Return values from your module

Report which school was selected from the module.

## Take reactive values

Receive a reactive value that sets the selected school.

## Return anything!

Return the reported school and an `update_school()` function.